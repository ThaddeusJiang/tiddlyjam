{
    "tiddlers": {
        "$:/config/sq/OverwriteBinaryFiles": {
            "title": "$:/config/sq/OverwriteBinaryFiles",
            "created": "20210331123857536",
            "modified": "20210331125534389",
            "type": "text/vnd.tiddlywiki",
            "text": "yes"
        },
        "$:/config/sq/SaveAsExternalFile": {
            "title": "$:/config/sq/SaveAsExternalFile",
            "created": "20210330153139725",
            "modified": "20210331194622196",
            "type": "text/vnd.tiddlywiki",
            "text": "yes"
        },
        "$:/core/ui/ViewTemplate/import-external-files": {
            "title": "$:/core/ui/ViewTemplate/import-external-files",
            "created": "20200424200802765",
            "list-after": "body",
            "modified": "20210331194438556",
            "tags": "$:/tags/ViewTemplate",
            "type": "text/vnd.tiddlywiki",
            "text": "<$list filter=\"[all[current]field:plugin-type[import]]\" variable=\"null\">\n\n<$checkbox tiddler=\"$:/config/sq/SaveAsExternalFile\" field=\"text\" checked=\"yes\" unchecked=\"no\" default=\"yes\"> Import binary files as external attachments</$checkbox>\n\n<$list filter=\"[{$:/config/sq/SaveAsExternalFile}match[yes]]\" variable=\"null\">\n<$checkbox tiddler=\"$:/config/sq/OverwriteBinaryFiles\" field=\"text\" checked=\"yes\" unchecked=\"no\" default=\"yes\"> Overwrite binary files with the same name</$checkbox>\n</$list>\n\n</$list>"
        },
        "$:/sq/ServerImages/ServerImages": {
            "title": "$:/sq/ServerImages/ServerImages",
            "text": "/*\\\ntitle: $:/sq/ServerImages/ServerImages.js\ntype: application/javascript\nmodule-type: startup\n\nThis adds a hook for the \"th-importing-tiddler\"\n\n\\*/\n(function () {\n\n\t/*jslint node: true, browser: true */\n\t/*global $tw: false */\n\t\"use strict\";\n\n\t// Export name and synchronous status\n\texports.name = \"sq-server-images\";\n\texports.platforms = [\"browser\"];\n\texports.after = [\"render\"];\n\texports.synchronous = true;\n\n\texports.startup = function() {\n\tfunction updateProgress(e) {\n\t\t// TODO make this work in different browsers\n\t\t/*\n\t\tif (e.lengthComputable) {\n\t\tvar percentComplete = e.loaded/e.total*100;\n\t\t} else {\n\t\tvar percentComplete = -1;\n\t\t}\n\t\tconsole.log(percentComplete);\n\t\t*/\n\t}\n\tfunction transferComplete(e) {\n\t\tconsole.log('Complete!!',e);\n\t}\n\tfunction transferFailed(e) {\n\t\tconsole.log('Failed!');\n\t}\n\tfunction transferCanceled(e) {\n\t\tconsole.log('Cancelled!')\n\t}\n\t// Add the hook to the wiki in the browser\n\t$tw.hooks.addHook(\"th-importing-tiddler\", function(tiddler) {\n\t\t\n\t\tvar saveAsExternal = $tw.wiki.getTextReference(\"!!text\",\"yes\",\"$:/config/sq/SaveAsExternalFile\") === \"yes\" ? true : false;\n\t\tif(!saveAsExternal) {\n\t\t\treturn tiddler;\n\t\t}\n\t\t\n\t\t// Figure out if the thing being imported is something that should be\n\t\t// saved on the server.\n\t\tvar mediaTypes = ['image/gif', 'image/x-icon', 'image/jpeg', 'image/jpeg', 'image/png', 'image/svg+xml', 'application/pdf', 'application/zip', 'application/font-woff', 'application/x-font-ttf', 'audio/ogg', 'video/mp4', 'audio/mp3', 'audio/mp4'];\n\t\tif (mediaTypes.indexOf(tiddler.fields.type) > -1 && !tiddler.fields._canonical_uri) {\n\t\t\t// Check if this is set up to use HTTP post or websockets to save the\n\t\t\t// image on the server.\n\t\t\tvar request = new XMLHttpRequest();\n\t\t\trequest.upload.addEventListener('progress', updateProgress);\n\t\t\trequest.upload.addEventListener('load', transferComplete);\n\t\t\trequest.upload.addEventListener('error', transferFailed);\n\t\t\trequest.upload.addEventListener('abort', transferCanceled);\n\n            request.onreadystatechange = function() {\n                if (this.readyState == 4 && this.status == 200) {\n                    console.log(this.response);\n                    var json = null;\n                    try {\n                        json = JSON.parse(this.response);\n                    } catch (e) {\n                    }\n                    if(json) {\n                        console.log(json);\n                        var tiddler = $tw.wiki.getTiddler(json.tiddler);\n                        $tw.wiki.addTiddler(new $tw.Tiddler(tiddler,{_canonical_uri: json._canonical_uri, text:\"\"}));\n                    }\n                };\n            }\n\t\t\tvar uploadURL = '/api/upload';\n\t\t\trequest.open('POST', uploadURL, true);\n\n\t\t\tvar thing = {\n\t\t\t\ttiddler: tiddler\n\t\t\t}\n\t\t//\trequest.upload.addEventListener('load', transferComplete);\n\t\t\trequest.setRequestHeader(\"X-Requested-With\",\"TiddlyWiki\");\n\t\t\trequest.send(JSON.stringify(thing));\n\n\t\t\t// Change the tiddler fields and stuff\n\t\t\tvar fields = {};\n\t\t\tvar uri = '/files/'+tiddler.fields.title;\n\t\t\t//Use tw.utils.generateTiddlerFilePath //remove / etc from title\n\t\t\t//https://github.com/Jermolene/TiddlyWiki5/blob/master/core/modules/utils/filesystem.js#L321\n\t\t\tfields.title = tiddler.fields.title;\n\t\t\tfields.type = tiddler.fields.type;\n\t\t\tfields._canonical_uri = uri;\n\t\t\t//return new $tw.Tiddler(fields);\n            return tiddler;\n\t\t} else {\n\t\t\treturn tiddler;\n\t\t}\n\t});\n\t}\n\n})();",
            "type": "application/javascript",
            "module-type": "startup",
            "created": "20200423232749510",
            "modified": "20210329123207238",
            "tags": ""
        },
        "$:/sq/ServerRoutes/post-upload": {
            "title": "$:/sq/ServerRoutes/post-upload",
            "text": "/*\\\ntitle: $:/sq/ServerRoutes/post-upload.js\ntype: application/javascript\nmodule-type: route\n\nPOST /^\\/api\\/upload/\n\nUpload media\n\n\\*/\n(function() {\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nexports.method = \"POST\";\n\nexports.path = new RegExp('^\\/api\\/upload');\nexports.bodyFormat = \"stream\";\n\n\tconst fs = require('fs')\n\tconst path = require('path')\n\tconst buffer = require('buffer')\n\nexports.handler = function(request,response,state) {\n\n\t\n\tlet body = ''\n\t\n\trequest.on('data', function(chunk){\n\t\tbody += chunk;\n\t\t// We limit the size of an upload to 10mb for now.\n\t\tif(body.length > 10e6) {\n\t\t\tresponse.writeHead(413, {'Content-Type': 'text/plain'}).end();\n\t\t\trequest.connection.destroy();\n\t\t}\n\t});\n\t\n\trequest.on('end', function() {\n\t\ttry {\n\t\t\tlet bodyData = JSON.parse(body)\n\n\t\t\tconst filesPath = path.resolve($tw.boot.wikiTiddlersPath, \"../files\");\n\n            //config option overwrite existing?\n\t\n            /*    \n            var xfilepath = $tw.utils.generateTiddlerFilepath(bodyData.tiddler.fields.title,{\n                directory: filesPath\n            });\n            //var ext = path.extname(originalpath);\n            //xfilepath = xfilepath.substring(0,xfilepath.length - ext.length);\n            \n            \n            // 1) try to increment filename before extension.\n            // 2) don't encode / in file path so can specify a subdir\n            xfilepath = path.join(filesPath, bodyData.tiddler.fields.title); //with this tiddler titles like images/filename work but only if directory exists\n            console.log(xfilepath);\n\t\t\t*/\n            var xfilepath = generateBinaryFilePath(bodyData.tiddler.fields.title);\n\t\t\tconsole.log(xfilepath);\n\t\t\t$tw.utils.createDirectory(filesPath);\n\t\t\tconst buf = Buffer.from(bodyData.tiddler.fields.text,'base64');\n\t\t\t//const filename = path.join(filesPath, bodyData.tiddler.fields.title);\n\t\t\tconst filename = xfilepath;\n            fs.writeFile(path.join(xfilepath), buf, function(error) {\n\t\t\t\tif (error) {\n\t\t\t\t\tconsole.log(error);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(\"External file saved: \" + filename);\n\t\t\t\t\tresponse.setHeader('Content-Type', 'application/json');\n\t\t\t\t\tresponse.end(JSON.stringify( {\n                            \"success\": \"saved \" + bodyData.tiddler.fields.title,\n                            \"status\": 200,\n                            //\"_canonical_uri\":\t \"files/\" + bodyData.tiddler.fields.title,\n                            \"_canonical_uri\": path.relative(path.resolve($tw.boot.wikiTiddlersPath,\"..\"),xfilepath),\n\t\t\t\t\t\t\t\"tiddler\": bodyData.tiddler.fields.title\n                        }));\n                    //state.wiki.addTiddler(bodyData.tiddler.fields,{_canonical_uri : bodyData.tiddler.fields.title, text:\"\"},state.wiki.getModificationFields());\n\t\t\t\t\t\t//return true;\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (e) {\n\t\t\tconsole.log('Error parsing uploaded file', e, {'level': 2});\n\t\t\tresponse.writeHead(400);\n\t\t\tresponse.end();\n\t\t}\n\t})\n};\n\nvar generateBinaryFilePath = function(title,options) {\n    const filesDirPath = path.resolve($tw.boot.wikiTiddlersPath,\"../files\");\n\t// Remove any forward or backward slashes so we don't create directories\n\tvar filepath = title.replace(/\\/|\\\\/g,\"_\");\n\t// Replace any Windows control codes\n\tfilepath = filepath.replace(/^(con|prn|aux|nul|com[0-9]|lpt[0-9])$/i,\"_$1_\");\n\t// Replace any leading spaces with the same number of underscores\n\tfilepath = filepath.replace(/^ +/,function (u) { return u.replace(/ /g, \"_\")});\n\t//If the path does not start with \".\" or \"..\" && a path seperator, then\t\n\tif(!/^\\.{1,2}[/\\\\]/g.test(filepath)) {\n\t\t// Don't let the filename start with any dots because such files are invisible on *nix\n\t\tfilepath = filepath.replace(/^\\.+/g,function (u) { return u.replace(/\\./g, \"_\")});\n\t}\n\t// Replace any Unicode control codes\n\tfilepath = filepath.replace(/[\\x00-\\x1f\\x80-\\x9f]/g,\"_\");\n\t// Replace any characters that can't be used in cross-platform filenames\n\tfilepath = $tw.utils.transliterate(filepath.replace(/<|>|~|\\:|\\\"|\\||\\?|\\*|\\^/g,\"_\"));\n\tvar extension = path.extname(title);\n\t//remove extension from filepath\n\tfilepath = filepath.substring(0,filepath.length - extension.length);\n\t// Replace any dots or spaces at the end of the extension with the same number of underscores\t\n\textension = extension.replace(/[\\. ]+$/, function (u) { return u.replace(/[\\. ]/g, \"_\")});\n\t// Truncate the extension if it is too long\n\tif(extension.length > 32) {\n\t\textension = extension.substr(0,32);\n\t}\n\t// Truncate the filename if it is too long\n\tif(filepath.length > 200) {\n\t\tfilepath = filepath.substr(0,200);\n\t}\n\t// If the resulting filename is blank (eg because the title is just punctuation)\n\tif(!filepath || /^_+$/g.test(filepath)) {\n\t\t// ...then just use the character codes of the title\n\t\tfilepath = \"\";\t\n\t\t$tw.utils.each(title.split(\"\"),function(char) {\n\t\t\tif(filepath) {\n\t\t\t\tfilepath += \"-\";\n\t\t\t}\n\t\t\tfilepath += char.charCodeAt(0).toString();\n\t\t});\n\t}\n\t\n\t\n\tvar overwrite = $tw.wiki.getTextReference(\"!!text\",\"yes\",\"$:/config/sq/OverwriteBinaryFiles\") === \"yes\" ? true : false;\n\tif(overwrite) {\n\t\treturn path.resolve(filesDirPath,filepath + extension);\n\t}\n\t\n\tvar fullPath,\n\t\tcount = 0;\n\tdo {\n\t\tfullPath = path.resolve(filesDirPath,filepath + (count ? \"_\" + count : \"\") + extension);\n\t\tcount++;\n\t} while(fs.existsSync(fullPath));\t\n\treturn fullPath;\n}\n\n\n}());",
            "type": "application/javascript",
            "module-type": "route",
            "created": "20200423232422657",
            "modified": "20210329123207234",
            "tags": ""
        }
    }
}